#!/usr/bin/env python
import argparse
import subprocess
import sys
import os
import json
from os import environ, path, access
from shutil import which, copyfile
from time import time

def main(repo: str, dependencies: list[str], default_build: str):
  timestamp: int = int(time())
  home: str = environ["HOME"]
  paths: str = environ["PATH"]
  zshrc: str = path.join(home, ".zshrc")
  bin_dirs: list[str] = []
  missing: list[str] = []
  build: str = path.join(home, default_build)
  version: str = ""
  binary: str = ""

  parser = argparse.ArgumentParser(description="Dotfiles install script")
  parser.add_argument(
    "-D", "--dev",
    action="store_true",
    dest='dev',
    default=False
  )
  parser.add_argument(
    "-L", "--lang",
    action="store",
    dest="lang",
    default="go"
  )
  parser.add_argument(
    "-B", "--base",
    action="store",
    dest="base",
    default=".dotfiles",
    type=str
  )

  args = parser.parse_args()
  dependencies.append(args.lang)
  base = path.join(home, args.base)
  is_dev = args.dev
  tools = path.join(base, "tools", args.lang)

  if not is_dev:
    print(f"Cloning to {base}...")
    subprocess.call(f"git clone {repo} {base}", shell=True)

  if not path.exists(base):
    print("Failed to clone")
    sys.exit(1)

  print("Finding PATH directories...")
  for dir in paths.split(":"):
    if access(dir, os.W_OK | os.R_OK) and "sbin" not in dir:
      bin_dirs.append(dir)

  if len(bin_dirs) == 0:
    print("No valid directory in PATH")
    sys.exit(1)

  print("Checking required system packages...")
  for dep in dependencies:
    if dep != "omz" and dep != "nvm":
      exists = which(dep)

      if exists == None:
        missing.append(dep)
    else:
      # For each of these special circumstances I need
      # to simulate the ZSH environment and check for the
      # required packages that way. Otherwise, it is less
      # reliable and harder to consistently track.
      if dep == "omz":
        command = 'zsh -i -c "which omz && omz version"'
        code = subprocess.run(command, shell=True, capture_output=True, text=True).returncode

        if code != 0:
          missing.append(dep)

      if dep == "nvm":
        command = 'zsh -i -c "which nvm && nvm version"'
        code = subprocess.run(command, shell=True, capture_output=True, text=True).returncode

        if code != 0:
          missing.append(dep)

  if len(missing) > 0:
    print("\nMissing required packages:")

    for dep in missing:
      print(f"> {dep}")

    print("\nPlease install required packages and try again")
    sys.exit(1)

  if path.exists(zshrc):
    print("Backing up existing .zshrc...")
    copyfile(zshrc, path.join(home, f".zshrc.{timestamp}.backup"))

  print("Determining build path...")
  if build not in bin_dirs:
    idx = 0

    if bin_dirs[0][0] == "/":
      idx = 1

    build = bin_dirs[0][idx:]

  print("Building dotfiles CLI...")
  if path.exists(tools):
    with open(path.join(base, "dotfiles.json"), 'r') as file:
      data = json.load(file)
      version = data["version"]
      binary = data["binary"]

    subprocess.call(
      f"python {path.join(tools, "build")} --symlink={build} --binary={binary}",
      cwd=path.join(os.getcwd(), args.base),
      shell=True,
    )

    print(f"version: {version}")
  else:
    print("Failed to build dotfiles CLI")
    sys.exit(1)

if __name__ == "__main__":
  main(
    # Where to clone the repo from. Changing this changes
    # which repo is cloned.
    repo="https://github.com/jgttech/dotfiles.v2.git",

    # The packages that the system needs to have to install.
    # This can't be inside a JSON or other file because
    # we need to check these before installing the dotfiles.
    # These should only be what is required to install the
    # dotfiles.
    dependencies=["git", "stow", "omz", "nvm"],

    # This is the default location where, under the HOME
    # path of the user, the dotfiles will link the build
    # to, to make it available in the PATH automatically.
    #
    # However, if this path is not found, it will check
    # the PATH for user accessible directories and pick
    # the first one it finds and try to link the build
    # there so it is automatically available.
    #
    # Unfortunately, I have to use this approach because
    # some systems will not have this in their PATH and
    # instead of making the user modify their PATH I can
    # just detect what options exist and use of those.
    default_build=".local/bin"
  )
